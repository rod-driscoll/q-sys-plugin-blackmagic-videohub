-- Q-Sys plugin for BlackMagic VideoHub
-- <https://documents.blackmagicdesign.com/UserManuals/Videohub12GInstallation.pdf?_v=1680591612000>
-- 20231212 v1.0.0 Rod Driscoll<rod@theavitgroup.com.au>

-- Information block for the plugin
PluginInfo = {
  Name = "BlackMagic~VideoHub", -- The tilde here indicates folder structure in the Shematic Elements pane
  Version = "1.0.0",
  Id = "blackmagic-videohub.plugin.1.0.0",
  Description = "Plugin for controlling a BlackMagic VideoHub",
  ShowDebug = true,
  Author = "Rod Driscoll"
}

-- Define the color of the plugin object in the design
function GetColor(props)
  return { 102, 102, 102 }
end

-- The name that will initially display when dragged into a design
function GetPrettyName()
	return "BlackMagic VideoHub " .. PluginInfo.Version
end

-- Optional function used if plugin has multiple pages
local PageNames = {"Setup","Device"} --List the pages within the plugin
function GetPages(props)
  local pages = {}
  for ix,name in ipairs(PageNames) do
    table.insert(pages, {name = PageNames[ix]})
  end
  return pages
end

-- Define User configurable Properties of the plugin
function GetProperties()
	local props = {}
  table.insert(props,{
    Name = 'Input Count',
    Type = 'integer',
    Min = 2,
    Max = 127,
    Value = 6
  })
  table.insert(props,{
    Name = 'Output Count',
    Type = 'integer',
    Min = 1,
    Max = 127,
    Value = 2
  })
  table.insert(props,{
    Name    = "Connection Type",
    Type    = "enum", 
    Choices = {"Ethernet", "Serial"},
    Value   = "Ethernet"
  })
  table.insert(props,{
    Name  = "Poll Interval",
    Type  = "integer",
    Min   = 1,
    Max   = 60, 
    Value = 60
  })
  table.insert(props,{
    Name    = "Debug Print",
    Type    = "enum",
    Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function Calls", "All"},
    Value   = "None"
  })
	return props
end

-- Optional function to define pins on the plugin that are not connected to a Control
function GetPins(props)
  local pins = {}
  if props["Connection Type"].Value=="Serial" then 
    table.insert(pins,{Name="input", Direction="input", Domain="serial"})
  end
  return pins
end

-- Optional function to update available properties when properties are altered by the user
function RectifyProperties(props)
  if props.plugin_show_debug.Value == false then 
    props["Debug Print"].IsHidden = true 
  end
	return props
end

-- Defines the Controls used within the plugin
function GetControls(props)
  local ctrls = {}
  
  table.insert(ctrls, {
    Name         = "code",
    ControlType  = "Text",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Input"
  })
  
  -- Configuration Controls --
  table.insert(ctrls, {
    Name         = "IPAddress",
    ControlType  = "Text",
    Count        = 1,
    DefaultValue = "Enter an IP Address",
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "TcpPort",
    ControlType  = "Knob",
    ControlUnit  = "Integer",
    DefaultValue = 9990,
    Min          = 1,
    Max          = 65535,
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "ModelName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "DeviceName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "DeviceFirmware",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "SerialNumber",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  
  -- Status Controls --
  table.insert(ctrls, {
    Name          = "Status",
    ControlType   = "Indicator",
    IndicatorType = Reflect and "StatusGP" or "Status",
    PinStyle      = "Output",
    UserPin       = true,
    Count         = 1
  })
  
  table.insert(ctrls, {
    Name         = "TakeMode",
    ControlType  = "Button",
    ButtonType   = "Toggle",
    PinStyle     = "Both",
    UserPin      = true,
    Count        = 1
  })
  
      -- Switching Controls --
      for i = 0, props['Output Count'].Value-1 do
        for s = 0, props['Input Count'].Value-1 do
            table.insert(ctrls, {
                    Name = "vid-input_" .. s .. "-output_" .. i,
                    ControlType = "Button",
                    ButtonType = "Toggle",
                    PinStyle = "Both",
                    UserPin = true
                }
            )
        end
    end
  
  -- input Controls --
  for i = 0, props['Input Count'].Value-1 do
    table.insert(ctrls,{
      Name         = "input_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Input " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
  end
  
  -- output Controls --
  for i = 0, props['Output Count'].Value-1 do
    table.insert(ctrls,{
      Name         = "output_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Output " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-lock",
      ControlType  = "Button",
      ButtonType   = "Toggle",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
  end
  return ctrls
end

--Layout of controls and graphics for the plugin UI to display
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
  local CurrentPage = PageNames[props["page_index"].Value]
  	
  local colors = {  -- taken from some other plugin and not really kept track
    Background  = {232,232,232},
    Transparent = {255,255,255,0},
    Text        = {24,24,24},
    Header      = {0,0,0},
    Button      = {48,32,40},
    Red         = {217,32,32},
    DarkRed     = {80,16,16},
    Green       = {32,217,32},
    OKGreen     = {48,144,48},
    Blue        = {32,32,233},
    Black       = {0,0,0},
    White       = {255,255,255},
    Gray        = {96,96,96}
  }
  
  local function label(graphic)
    for k,v in pairs({
      Type = 'Label',
      Color = { 0, 0, 0 },
      HTextAlign = 'Right',
      FontSize = 14
    }) do graphic[k] = graphic[k] or v; end;
    table.insert(graphics, graphic);
  end;
  
  local function textinput(layout)
    for k,v in pairs({
      Color = { 208, 208, 208 },
      StrokeColor = { 102, 102, 102 },
      StrokeWidth = 2,
      CornerRadius = 8,
      FontSize = 12,
      Margin = 10,
      TextBoxStyle = 'Normal'
    }) do layout[k] = layout[k] or v; end;
    return layout;
    end;
  
  layout["code"]={PrettyName="code",Style="None"}  
      
  if(CurrentPage == 'Setup') then
    -- User defines connection properties
    table.insert(graphics,{Type="GroupBox",Text="Connect",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,5},Size={400,120}})
    if props["Connection Type"].Value=="Ethernet" then 
      table.insert(graphics,{Type="Text",Text="IP Address",Position={15,35},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["IPAddress"] = {PrettyName="Settings~IP Address",Style="Text",Color=colors.White,Position={120,35},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="Port",Position={15,60},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["TcpPort"] = {PrettyName="Settings~Port",Style="Text",Position={120,60},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="(9990 default)",Position={221,60},Size={100,18},FontSize=10,HTextAlign="Left"})
    else
      table.insert(graphics,{Type="Text",Text="Reset Serial",Position={5,32},Size={110,16},FontSize=14,HTextAlign="Right"})
      layout["Reset"] = {PrettyName="Settings~Reset Serial", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={120,30}, Size={50,20} }
    end
  
    -- Status fields updated upon connect show model/name/serial/sw rev
    table.insert(graphics,{Type="GroupBox",Text="Status",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,135},Size={400,220}})
    layout["Status"] = {PrettyName="Status~Connection Status", Position={40,165}, Size={330,32}, Padding=4 }
    table.insert(graphics,{Type="Text",Text="Friendly Name",Position={15,212},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceName"] = {PrettyName="Status~Friendly Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,211}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Model Name",Position={15,235},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["ModelName"] = {PrettyName="Status~Model Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,234}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Serial Number",Position={15,258},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["SerialNumber"] = {PrettyName="Status~Serial Number", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,257}, Size={255,16} }
      table.insert(graphics,{Type="Text",Text="Software Version",Position={15,281},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceFirmware"] = {PrettyName="Status~SW Version", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,280}, Size={255,16} }
  
    table.insert(graphics,{Type="Text",Text=GetPrettyName(),Position={15,200},Size={380,14},FontSize=10,HTextAlign="Right", Color=colors.Gray})
  
  elseif(CurrentPage == 'Device') then 
    
    --local helper = require("Helpers")
    helper = {}
    helper.Copy = function(tbl, seen)
      if type(tbl) ~= 'table' then return tbl end
      if seen and seen[tbl] then return seen[tbl] end 
      local s = seen or {}
      local res = setmetatable({}, getmetatable(tbl))
      s[tbl] = res
      for k, v in pairs(tbl) do
          res[helper.Copy(k, s)] = helper.Copy(v, s)
      end
      if res==nil then print('Copy(): returning nil') end
      return res
    end  
  
    -- create objects for each section so they can be modified easily
  
    local UI_crosspoints = {
      Position    = { 0, 8 },
      --Size        = { 0, 0 }, -- GroupBox contains Size of the whole object
      --buttons
      Padding     = { 4, 4 },
      GroupPadding= { 4, 4 },
      Button      = { Style = "Button", Size = { 36, 36}, Margin = 0 },
      NameText    = { Style = "Text", Type="Text", Color=colors.White, FontSize=10, HTextAlign="Center", WordWrap = true },
      NumButtons  = { props['Input Count'].Value, props['Output Count'].Value },
      Label       = { Style = "Label", Size = { 74, 14} , Type="Text", FontSize=10, HTextAlign="Center", WordWrap = true },
      Buttons     = {}, -- to be filled in Init()
      --groupbox
      GroupBox    = { Type="GroupBox", Text="Crosspoints", StrokeWidth=1, CornerRadius=4, HTextAlign="Left" },
      
      Init = function (self)
        if self.NumButtons[1] > 12 or self.NumButtons[2] > 12 then 
          self.Padding     = { 1, 1 }
          self.Button.Size = { 18, 18 }
        end
        self.GroupBox.Size = {
          self.Padding[1] + self.NumButtons[1]*(self.Padding[1] + self.Button.Size[1]),
          self.Padding[2] + self.NumButtons[2]*(self.Padding[2] + self.Button.Size[2]) + self.Label.Size[2]
        }        
        self.GroupBox.Position  = self.Position
        self.Buttons = {}
  
        for i=0, self.NumButtons[1]-1 do
          --local lbl_ = helper.Copy(self.Label) todo
  
          for o=0, self.NumButtons[2]-1 do
            local btn_ = helper.Copy(self.Button)
            btn_['PrettyName'] = "Crosspoints~Output "..o.."~In" .. i .. " -> Out" .. o
            btn_['Legend'] = tostring(i)
            btn_['Position']={
              self.Position[1] + self.Padding[1] + i*(self.Button.Size[1] + self.Padding[1]),
              self.Position[2] + self.Padding[2] + o*(self.Button.Size[2] + self.Padding[2]) + self.Label.Size[2]
            }
            btn_.Layout_ID = "vid-input_" ..i.. "-output_" .. o
            table.insert(self.Buttons, btn_)
          end
        end
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,b in ipairs(self.Buttons) do 
          layout[b.Layout_ID] = b -- layout is the global layout
        end 
      end,
  
      GetButtonPositions = function(self) -- returns diagonal buttons for getting locations to line up other objects
        local pos_ = {}
        for i=0, self.NumButtons[1]-1 do
          pos_[i]={
            self.Position[1] + self.Padding[1] + i*(self.Button.Size[1] + self.Padding[1]),
            self.Position[2] + self.Padding[2] + i*(self.Button.Size[2] + self.Padding[2]) + self.Label.Size[2]
          }
        end
        return pos_
      end     
    }
  
    --UI_crosspoints.NumButtons = { props['Input Count'].Value, props['Output Count'].Value }
    --print(table.concat(UI_crosspoints:GetSize(),','))
  
    -- add outputs (names, locks)
    local UI_outputObjects = {
      Position    = helper.Copy(UI_crosspoints.Position),
      --buttons
      Padding     = helper.Copy(UI_crosspoints.Padding),
      --Button      = helper.Copy(UI_crosspoints.Button),
      NameText    = helper.Copy(UI_crosspoints.NameText), --Size = { 36, 54}      
      NumButtons  = props['Output Count'].Value,
      Buttons     = {}, -- to be filled in Init()
      --groupbox
      GroupBox    = helper.Copy(UI_crosspoints.GroupBox),
  
      Init = function(self)
        local positions = UI_crosspoints:GetButtonPositions()
        self.NameText.Size = { 54, UI_crosspoints.Button.Size[2] }
        self.LockButtons = {}
        -- GroupBox
        self.GroupBox.Size = {
          self.Padding[1], -- horiz, to be increased as buttons added
          UI_crosspoints.GroupBox.Size[2] -- vert same as crosspoint GroupBox
        }        
        self.GroupBox.Position = self.Position
        self.GroupBox.Text="Outputs"
  
        for o=0, self.NumButtons-1 do
          -- Names
          local name_ = helper.Copy(self.NameText)
          name_['PrettyName'] = "Outputs~".. o .."~name"
          name_['Position']={ positions[0][1], positions[o][2] } -- horiz always the same, vert moves down
          name_.Layout_ID = "output_" .. o .. "-name"
          if o==0 then self.GroupBox.Size[1] = self.GroupBox.Size[1] + name_.Size[1] + self.Padding[1] end
          table.insert(self.Buttons, name_)
          
          -- Locks
          local btn_ = helper.Copy(UI_crosspoints.Button)
          name_['PrettyName'] = "Outputs~".. o .."~lock"
          btn_['Legend'] = tostring(o)
          btn_['Position']={ 
            name_.Position[1] + name_.Size[1] + self.Padding[1], -- horiz always the same
            positions[o][2] -- vert moves down to line up with the crosspoint buttons
          } 
          btn_.Layout_ID = "output_" .. o .. "-lock"
          if o==0 then self.GroupBox.Size[1] = self.GroupBox.Size[1] + btn_.Size[1] + self.Padding[1] end
  
          table.insert(self.Buttons, btn_)
        end
        -- set new position of UI_Crosspoints
        UI_crosspoints.Position[1] = self.GroupBox.Position[1] + self.GroupBox.Size[1] + self.Padding[1]  -- move the xpts over
        UI_crosspoints:Init() -- update locations of all internal objects
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,b in ipairs(self.Buttons) do 
          layout[b.Layout_ID] = b -- layout is the global layout
        end 
      end
    }
  
   -- add inputs (names)
   local UI_inputObjects = {
    Position    = {},
    --buttons
    Padding     = helper.Copy(UI_crosspoints.Padding),
    Button      = helper.Copy(UI_crosspoints.Button),
    NameText    = helper.Copy(UI_crosspoints.NameText), --Size = { 36, 54}      
    NumButtons  = props['Input Count'].Value,
    Buttons     = {}, -- to be filled in Init()
    --groupbox
    GroupBox    = helper.Copy(UI_crosspoints.GroupBox),
  
    Init = function(self)
      local positions = UI_crosspoints:GetButtonPositions()
      self.NameText.Size = { UI_crosspoints.Button.Size[1], 54 }
      -- GroupBox   
      self.GroupBox.Size = {
        UI_crosspoints.GroupBox.Size[1], -- horiz, same as crosspoints
        UI_crosspoints.Label.Size[2] + self.Padding[2], -- vert, increase as objects added
      }        
      self.Position = {
        UI_crosspoints.GroupBox.Position[1],
        UI_crosspoints.GroupBox.Position[2] + UI_crosspoints.GroupBox.Size[2] + self.Padding[2]
      }
      self.GroupBox.Position = self.Position
      self.GroupBox.Text="Inputs"
  
      for i=0, self.NumButtons-1 do
        -- Names
        local name_ = helper.Copy(self.NameText)
        name_['PrettyName'] = "Inputs~".. i .."~name"
        name_['Position']={ 
          positions[i][1], -- horiz moves accross
          UI_crosspoints.Label.Size[2] + self.Padding[2] + self.GroupBox.Position[2] -- vert always the same
        }
        name_.Layout_ID = "input_" .. i .. "-name"
  
        if i==0 then self.GroupBox.Size[2] = self.GroupBox.Size[2] + name_.Size[2] + self.Padding[2] end
        table.insert(self.Buttons, name_)
      end
    end,
  
    Draw = function(self, layout)
      table.insert(graphics, self.GroupBox)
      for _,b in ipairs(self.Buttons) do 
        layout[b.Layout_ID] = b -- layout is the global layout
      end 
    end
  }
    -- move base position of xpts
  
    UI_outputObjects.Position = helper.Copy(UI_crosspoints.Position)
  
  
    UI_crosspoints.Position = { UI_crosspoints.Position[1], UI_crosspoints.Position[2] } -- move UI_crosspoints over
    --UI_crosspoints:AddRowToLeft()
  
    UI_crosspoints:Init() -- initialize the crosspoints so other components can reference it's positions
    UI_outputObjects:Init() -- this also moves crosspoints to the right
    UI_inputObjects:Init()
    
    UI_crosspoints:Draw(layout)
    UI_outputObjects:Draw(layout)
    UI_inputObjects:Draw(layout)
  
    -- add some group boxes and labels to make it pretty
  
  end
  return layout, graphics
end

--Start event based logic
if Controls then
  local helper = require('Helpers')
  
  -- Control aliases
  Status = Controls.Status
  
  local SimulateFeedback = true
  -- Variables and flags
  DebugTx=false
  DebugRx=false
  DebugFunction=false
  DebugPrint=Properties["Debug Print"].Value	
  
  -- Timers, tables, and constants
  StatusState = { OK = 0, COMPROMISED = 1, FAULT = 2, NOTPRESENT = 3, MISSING = 4, INITIALIZING = 5 }
  Heartbeat = Timer.New()
  VolumeDebounce = Timer.New()
  PollRate = Properties["Poll Interval"].Value
  Timeout = PollRate + 10
  BufferLength = 1024
  ConnectionType = Properties["Connection Type"].Value
  DataBuffer = ""
  CommandQueue = {}
  CommandProcessing = false
  --Internal command timeout
  CommandTimeout = 5
  CommunicationTimer = Timer.New()
  TimeoutCount = 0
  
  --Hide controls that are just for pins
  --Controls["ModelNumber"].IsInvisible=true
  --Controls["PanelType"].IsInvisible=true
  
  	local Request = {
  		--Status		={Command="",				Data=""},
  		--Login			={Command="LOGIN",	Data=""},
  		--Logout		={Command="LOGOUT",	Data=""},
  		OutputLock={Command="VIDEO OUTPUT LOCKS"  , 	Data=""},
  		Route			={Command="VIDEO OUTPUT ROUTING", 	Data=""},
  }
  -- Query routes: 'VIDEO OUTPUT ROUTING: \x0a\x0a'
  -- Set route:    'VIDEO OUTPUT ROUTING:\x0a10 2\x0a\x0a'
  
  -- Helper functions
  -- A function to determine common print statement scenarios for troubleshooting
  function SetupDebugPrint()
  	if DebugPrint=="Tx/Rx" then
  		DebugTx,DebugRx=true,true
  	elseif DebugPrint=="Tx" then
  		DebugTx=true
  	elseif DebugPrint=="Rx" then
  		DebugRx=true
  	elseif DebugPrint=="Function Calls" then
  		DebugFunction=true
  	elseif DebugPrint=="All" then
  		DebugTx,DebugRx,DebugFunction=true,true,true
  	end
  end
  
  -- A function to clear controls/flags/variables and clears tables
  function ClearVariables()
  	if DebugFunction then print("ClearVariables() Called") end
  	Controls["DeviceFirmware"].String = ""
  	Controls["ModelName"].String = ""
  	Controls["DeviceName"].String = ""
  	DataBuffer = ""
  	CommandQueue = {}
  end
  
  --Reset any of the "Unavailable" data;  Will cause a momentary colision that will resolve itself the customer names the device "Unavailable"
  function ClearUnavailableData()
  	if DebugFunction then print("ClearUnavailableData() Called") end
  	-- If data was unavailable reset it; the next poll loop will test for it again
  	for i,ctrl in ipairs({ "DeviceFirmware", "ModelName" }) do
  		if(Controls[ctrl].String == "Unavailable")then
  			Controls[ctrl].String = ""
  		end
  	end
  end
  
  -- Update the Status control
  function ReportStatus(state,msg)
  	if DebugFunction then print("ReportStatus() Called: "..state..". "..msg) end
  	local msg=msg or ""
  	Status.Value=StatusState[state]
  	Status.String=msg
  end
  
  
  function Split(s, delimiter)
  	if DebugFunction then print("Split() Called") end
  	local result = {};
  	for match in (s..delimiter):gmatch("(.-)"..delimiter) do
  		table.insert(result, match);
  	end
  	return result;
  end
  
  --Parse a string from byte array
  function ParseString(data)
  	if DebugFunction then print("ParseString() Called") end
  	local name = ""
  	for i,byte in ipairs(data) do
  		name = name .. string.char(byte)
  	end
  	return name
  end
  
  function GetPrintableHexString(str)
  	local result_ = ""
  	for i=1, #str do
  		local c = str:sub(i,i)
  		if c:byte() > 0x1F and c:byte() < 0x7F then
  			result_ = result_..c
  		else
  			result_ = result_..string.format("\\x%02X", c:byte())
  		end
  	end
  	return result_  
  end
  
  --A debounce timer on power up avoids reporting the TCP reset that occurs as ane error
  function ClearDebounce()
  	PowerOnDebounce = false
  end
  -------------------------------------------------------------------------------
  -- Device functions
  -------------------------------------------------------------------------------
  
  --[[  Communication format
  	All commands are  of the format:
  	CommandName   Constant   Parameters   Suffix
  	<Command>     ':\x0a'    <Data>      '\x0a\x0a'
  
    e.g. 'VIDEO OUTPUT ROUTING:\x0a10 2\x0a\x0a'
  
  	Both Serial and TCP mode must contain functions:
  	Connect()
  	And a receive handler that passes data to ParseData()
  ]]
  
  -- Take a request object and queue it for sending.  Object format is of:
  --  { Command=string, Data={string} }
  function Send(cmd, sendImmediately)
  	value = string.format("%s:\x0a%s\x0a\x0a",cmd.Command, cmd.Data)
  	if DebugFunction then print("DoSend("..value..") Called") end
  
  	--Check for if a command is already queued
  	for i, val in ipairs(CommandQueue) do
  		if(val == value)then
  			--Some Commands should be sent immediately
  			if sendImmediately then
  				--remove other copies of a command and move to head of the queue
  				table.remove(CommandQueue,i)
  				if DebugTx then print("Sending: "..GetPrintableHexString(value)) end
  				table.insert(CommandQueue,1,value)
  			end
  			return
  		end
  	end
  	--Queue the command if it wasn't found
  	table.insert(CommandQueue,value)
  	SendNextCommand()
  end
  
  --Timeout functionality
  -- Close the current and start a new connection with the next command
  -- This was included due to behaviour within the Comms Serial; may be redundant check on TCP mode
  CommunicationTimer.EventHandler = function()
  	if DebugFunction then print("CommunicationTimer Event (timeout) Called") end
  	ReportStatus("MISSING","Communication Timeout")
  	CommunicationTimer:Stop()
  	CommandProcessing = false
  	SendNextCommand()
  end 
  
  	--  Serial mode Command function  --
  if ConnectionType == "Serial" then
  	print("Serial Mode Initializing...")
  	-- Create Serial Connection
  	Comms = SerialPorts[1]
  	Baudrate, DataBits, Parity = 9600, 8, "N"
  
  	--Send the display the next command off the top of the queue
  	function SendNextCommand()
  	if DebugFunction then print("SendNextCommand("..CommandProcessing..") Called") end
  	if CommandProcessing then
  		-- Do Nothing
  	elseif #CommandQueue > 0 then
  		CommandProcessing = true
  		if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  		Comms:Write( table.remove(CommandQueue,1) )
  		CommunicationTimer:Start(CommandTimeout)
  	else
  		CommunicationTimer:Stop()
  	end
  	end
  
  	function Disconnected()
  		if DebugFunction then print("Disconnected() Called") end
  		CommunicationTimer:Stop() 
  		CommandQueue = {}
  		Heartbeat:Stop()
  	end
  	
  		-- Clear old and open the socket, sending the next queued command
  	function Connect()
  		if DebugFunction then print("Connect() Called") end
  		Comms:Close()
  		Comms:Open(Baudrate, DataBits, Parity)
  	end
  
  	-- Handle events from the serial port
  	Comms.Connected = function(serialTable)
  		if DebugFunction then print("Connected handler called Called") end
  		ReportStatus("OK","")
  		Connected()
  	end
  	
  	Comms.Reconnect = function(serialTable)
  		if DebugFunction then print("Reconnect handler called Called") end
  		Connected()
  	end
  	
  	Comms.Data = function(serialTable, data)
  		ReportStatus("OK","")
  		CommunicationTimer:Stop() 
  		CommandProcessing = false
  		local msg = DataBuffer .. Comms:Read(1024)
  		DataBuffer = "" 
  		if DebugRx then 
  			if msg:len() < 50 then
  				print("Received["..#msg.."]: "..GetPrintableHexString(msg))
  			else
  				print("Received["..#msg.."]: "..msg:sub(1,50))
  			end 
  		end
  		ParseResponse(msg)
  		SendNextCommand()
  	end
  	
  	Comms.Closed = function(serialTable)
  		if DebugFunction then print("Closed handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING","Connection closed")
  	end
  	
  	Comms.Error = function(serialTable, error)
  		if DebugFunction then print("Socket Error handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING",error)
  	end
  	
  	Comms.Timeout = function(serialTable, error)
  		if DebugFunction then print("Socket Timeout handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING","Serial Timeout")
  	end
  
  	--[[
  	Controls["Reset"].EventHandler = function()
  		if DebugFunction then print("Reset handler called Called") end
  		PowerupTimer:Stop()
  		ClearVariables()
  		Disconnected()
  		Connect()
  	end
  	]]
  	
  	--  Ethernet Command Function  --
  else
  	print("TCP Mode Initializing...")
  	--IPAddress = Controls.IPAddress
  	--Port = Controls.Port
  	-- Create Sockets
  	Comms = TcpSocket.New()
  	Comms.ReconnectTimeout = 5
  	Comms.ReadTimeout = 10  --Tested to verify 6 seconds necessary for input switches;  Appears some TV behave mroe slowly
  	Comms.WriteTimeout = 10
  
  	--Send the display the next command off the top of the queue
  	function SendNextCommand()
  		if DebugFunction then print("SendNextCommand() Called") end
  		if CommandProcessing then
  		-- Do Nothing
  		elseif #CommandQueue > 0 then
  			if not Comms.IsConnected then
  				Connect()
  			else
  				CommandProcessing = true
  				if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  				Comms:Write( table.remove(CommandQueue,1) )
  			end
  		end
  	end
  	
  	function Disconnected()
  		if DebugFunction then print("Disconnected() Called") end
  		if Comms.IsConnected then
  			Comms:Disconnect()
  		end
  		CommandQueue = {}
  		Heartbeat:Stop()
  	end
  	
  	-- Clear old and open the socket
  	function Connect()
  		if DebugFunction then print("Connect() Called") end
  		if Controls.IPAddress.String ~= "Enter an IP Address" and Controls.IPAddress.String ~= "" then
  			if Comms.IsConnected then
  				Comms:Disconnect()
  			end
  			Comms:Connect(Controls.IPAddress.String, Controls.TcpPort.Value)
  		else
  			ReportStatus("MISSING","No IP Address or Port")
  		end
  	end
  		
  	-- Handle events from the socket;  Nearly identical to Serial
  	Comms.EventHandler = function(sock, evt, err)
  		if DebugFunction then print("Ethernet Socket EventHandler: "..tostring(evt)) end
  
  		if evt == TcpSocket.Events.Connected then
  			if DebugRx then print("Connected "..tostring(evt)) end
  			ReportStatus("OK","")
  			Connected()
  		elseif evt == TcpSocket.Events.Reconnect then
  		--Disconnected()
  	
  		elseif evt == TcpSocket.Events.Data then
  			ReportStatus("OK","")
  			CommandProcessing = false
  			TimeoutCount = 0
  			local line = sock:Read(BufferLength)
  			local msg = DataBuffer
  			DataBuffer = "" 
  			while (line ~= nil) do
  				msg = msg..line
  				line = sock:Read(BufferLength)
  			end 
  			if DebugRx then 
  				if msg:len() < 50 then
  					print("Received["..#msg.."]: "..GetPrintableHexString(msg))
  				else
  					print("Received["..#msg.."]: "..msg:sub(1,50))
  				end 
  			end
  			ParseResponse(msg)  
  			SendNextCommand()
  		
  		elseif evt == TcpSocket.Events.Closed then
  			if DebugRx then print("Disconnected "..tostring(evt)) end
  			Disconnected()
  			ReportStatus("MISSING","Socket closed")
  	
  		elseif evt == TcpSocket.Events.Error then
  			if DebugRx then print("Socket error "..tostring(err)) end
  			Disconnected()
  			ReportStatus("MISSING","Socket error")
  		
  		elseif evt == TcpSocket.Events.Timeout then
  			if DebugRx then print("Socket timeout error "..tostring(err)) end
  			TimeoutCount = TimeoutCount + 1
  			if TimeoutCount > 3 then
  				Disconnected()
  				ReportStatus("MISSING","Socket Timeout")
  			end
  	
  		else
  			if DebugRx then print("Socket unknown  "..tostring(err)) end
  			Disconnected()
  			ReportStatus("MISSING",err)
  		end
  	end
  
  	--Ethernet specific event handlers
  	Controls["IPAddress"].EventHandler = function()
  		if DebugFunction then print("IP Address Event Handler Called") end
  		if Controls["IPAddress"].String == "" then Controls["IPAddress"].String = "Enter an IP Address" end
  		ClearVariables()
  		Initialize()
  	end
  
  	Controls["TcpPort"].EventHandler = function()
  		if DebugFunction then print("Port Event Handler Called") end
  		ClearVariables()
  		Initialize()
  	end
  
  end
  
  function Query(cmd)
  	Send({
  		Command = cmd.Command .. "?",
  		Data = cmd.Data
  	})
  end
  
  function SetRouteLayerFeedback(layer, output, input)
  	if DebugFunction then print("SetRouteLayerFeedback(layer: "..layer..", output: "..output..", index: "..input..")") end
  	--if DebugFunction then print('Handling Route: "'..msg["Data"]..'"') end
  	if output~=nil and input~=nil then
  		local in_ = tonumber(input)
  		local out_ = tonumber(output)
  		if out_~=nil and out_ <= Properties['Output Count'].Value and in_~=nil and in_ <= Properties['Input Count'].Value then
  			for i=1, Properties['Input Count'].Value do
  				Controls["vid-input_"..i.."-output_" ..output].Boolean = (in_==i) 
  			end
  		end
  	end
  end
  
  function SetRouteAllFeedback(outputs)
  	if DebugFunction then print("SetRouteAllFeedback("..table.concat(outputs)..")") end
  	for o=1, #outputs do 
  		SetRouteLayerFeedback(Layers.Video, o, outputs[o])
  	end
  end
  
  --  Device Request and Data handlers
  
  --[[ Test the device once for
  	Model Number
  	Device Name
  	Model Name
  	Serial Number
  	SW Revision
  ]]
  
  -- Initial data grab from device
  function GetDeviceInfo()
  	if DebugFunction then print("GetDeviceInfo() Called") end
  	if Properties["Get Device Info"].Value then
      --QueryRoutes()
  	end
  end
  
  local function QueryRoutes()
  	Query({Command = Request["Route"].Command, Data = Layers.Video ..',*'})
  end
  
  function Connected()
  	if DebugFunction or DebugRx then print("Connected() Called") end
  	CommunicationTimer:Stop()
  	CommandProcessing = false
  	--Send({Command = Request["Help"].Command, Data = ""})
  	Heartbeat:Start(PollRate)   
  	--QueryRoutes()
  	SendNextCommand()
  end
  
  function ParseProtocol(str)
    --print('ParseProtocol('..str..')')
    local k_,v_ = str:match('([^:]+): (.+)')
    --print('ParseProtocol('..k_..', '..v_..')')
    if k_=='Version' then -- '2.8'
    		Controls["DeviceFirmware"].String = v_
    end
  end
  
  function ParseDevice(str)
    --print('ParseDevice('..str..')')
    local k_,v_ = str:match('([^:]+): (.+)')
    --print('ParseDevice('..k_..', '..v_..')')
    if k_=='Device present' then -- 'true'
    elseif k_=='Model name' then -- Smart Videohub 12G 40x40
      Controls["ModelName"].String = v_
    elseif k_=='Friendly name' then -- Smart Videohub 12G 40x40
      Controls["DeviceName"].String = v_
    elseif k_=='Unique ID' then -- '7C2E0DA49FCC'
    	Controls["SerialNumber"].String = v_
    elseif k_=='Video inputs' then -- '40'
     	Properties["Input Count"].Value = tonumber(v_)
    elseif k_=='Video processing units' then -- '0'
    elseif k_=='Video outputs' then -- '40'
     	Properties["Output Count"].Value = tonumber(v_)
    elseif k_=='Video monitoring outputs' then -- '0'
    elseif k_=='Serial ports' then -- '0'
    end
  end
  
  function ParseOutputLabels(str)
    --print('ParseOutputLabels('..str..')')
    local out_, name_ = str:match('(%d+) (.+)')
      --print('ParseOutputLabel('..out_..', '..name_..')')
      if Controls["output_" .. out_ .. "-name"]~=nil then
        Controls["output_" .. out_ .. "-name"].String = name_
      end
  end
  
  function ParseInputLabels(str)
    --print('ParseInputLabels('..str..')')
    local in_, name_ = str:match('(%d+) (.+)')
      --print('ParseInputLabel('..in_..', '..name_..')')
      if Controls["input_" .. in_ .. "-name"]~=nil then
        Controls["input_" .. in_ .. "-name"].String = name_
      end
  end
  
  function ParseLocks(str)
    --print('ParseLocks('..str..')')
    local out_, v_ = str:match('(%d+) ([LUO])') -- U:unlock, L:lock(returns O, not L), O:On (lock)
    -- outputs can be locked so that the system can't unlock them, in this case they return 'L' 
    if v_~=nil then
      local locked_ = v_~='U'  
      --print('ParseLocks('..out_..', '..tostring(locked_)..')')
      if Controls["output_" .. out_ .. "-lock"]~=nil then
        Controls["output_" .. out_ .. "-lock"].Boolean = locked_
        Controls["output_" .. out_ .. "-lock"].Legend = v_
      end
    end
  end
  
  function ParseRoute(str) -- input and output 0 exist
    --print('ParseRoute('..str..')')
    local out_, in_ = str:match('(%d+) (%d+)')
    print('ParseRoute('..out_..', '..in_..')')
    for i=0, Properties["Input Count"].Value do
      if Controls["vid-input_" .. i .. "-output_" .. out_]~=nil then
        print("Controls[vid-input_" .. i .. "-output_" .. out_..'].Boolean = '..tostring(i==tonumber(in_)))
        Controls["vid-input_" .. i .. "-output_" .. out_].Boolean = i==tonumber(in_)
      end
    end
  end
  
  function ParseConfig(str)
    --print('ParseConfig('..str..')')
    local k_,v_ = str:match('([^:]+): (.+)')
    --print('ParseConfig('..k_..', '..v_..')')
    if k_=='Take Mode' then -- 'true'
      --print(k_..', '..tostring(v_=='true')) 
      Controls["TakeMode"].Boolean = (v_=='true')
    end
  end 
  
  local callbacks_ = {
    ['PROTOCOL PREAMBLE']     = ParseProtocol,
    ['VIDEOHUB DEVICE']       = ParseDevice,
    ['OUTPUT LABELS']         = ParseOutputLabels,
    ['INPUT LABELS']          = ParseInputLabels,
    ['VIDEO OUTPUT LOCKS']    = ParseLocks,
    ['VIDEO OUTPUT ROUTING']  = ParseRoute,
    ['CONFIGURATION']         = ParseConfig,
    ['END PRELUDE'] = {},
    ['ACK']         = {},
    ['NAK']         = {}
  }
  
  function ParseResponse(msg)
  	local delimPos_ = msg:find("\x0a\x0a")
  	if DebugFunction then 
    	if delimPos_==nil then
          print("ParseResponse("..string.len(msg)..", delimiter not found) Called") 
          local g_ = msg:gmatch('(.-)\x0a\x0a') -- get the sections of data
          print("match == nil: "..tostring(g_==nil))
        else
          print("ParseResponse("..string.len(msg)..","..delimPos_..") Called") 
        end
    end
  	local valid_ = msg:len()>0 and delimPos_~=nil
  	--Message is too short, buffer the chunk and wait for more
  	if not valid_ then 
  		delimPos = delimPos or 0
  		if DebugRx then 
  			if msg:len() < 50 then 
  				print("invalid["..#msg..","..delimPos.."]: "..msg)
  			else
  				print("invalid["..#msg..","..delimPos.."]: "..msg:sub(1,50))
  			end 
  		end  
  		DataBuffer = DataBuffer .. msg
  	else
  		--Pack the data for the handler
      local cb_ = nil
      local g_ = msg:gmatch('(.-)\x0a\x0a') -- get the sections of data
      for m_ in g_ do
        --print('match: '..m_) -- good
        if m_:sub(-1)~='\x0a' then m_=m_..'\x0a' end -- the first match removed the \x0a from the last match
        local g1_ = m_:gmatch('(.-)\x0a')  -- e.g. "VIDEO OUTPUT ROUTING:\x0D\x0A2 3\x0D\x0A\x0D\x0A"i = 1
        local i = 1
        for m1_ in g1_ do
          --print('match1: '..m1_)
          if i==1 then
            m1_ = m1_:gsub(':','')
            if callbacks_[m1_]~=nil then 
              if m1_=='NAK' or m1_=='ACK' then 
                print(m1_..' received')
              else
                print('Parsing category: '..m1_)
                cb_=callbacks_[m1_]
              end
            else 
              print('unhandled category: '..m1_)
              cb_=nil
            end
          elseif cb_~=nil then cb_(m1_) end
          i=i+1
        end
      end 
  
  		--Re-process any remaining data
  		if delimPos_~=nil and (delimPos_+2 < msg:len()) then
  			ParseResponse( msg:sub(delimPos_+2,-1) )
  		end
  	end
  		
  end
  
  -------------------------------------------------------------------------------
  -- Device routing functions
  -------------------------------------------------------------------------------
  local function SetRoute(layer, dest, src, state)
  	if DebugFunction then print("Send layer " .. layer .. " from src " .. src .. " to dest " .. dest) end
  	local cmd_ = Request["Route"]
  	cmd_.Data = dest..' '.. src
  	Send(cmd_)
  	if SimulateFeedback then ParseResponse(string.format("%s\x0a %s\x0a\x0a", cmd_.Command, cmd_.Data)) end
  end
  
  local function SetOutputLock(index, value)
  	if DebugFunction then print("Set output " .. index .. " lock to " .. tostring(value)) end
  	local cmd_ = Request["OutputLock"]
  	cmd_.Data = index..' '.. (value and 'L' or 'U') -- U:unlock, L:lock(returns O, not L), O:On (lock)
    -- outputs can be locked so that the system can't unlock them, in this case they return 'L' 
  	Send(cmd_)
  end
  
  -------------------------------------------------------------------------------
  -- Initialize
  -------------------------------------------------------------------------------	
  function TestFeedbacks()
  end
  
  function Initialize()
  	if DebugFunction then print("Initialize() Called: "..GetPrettyName()) end
  	--helper.TablePrint(Controls, 1)
  
  	Layers = {
  		Video = 1,
  		Audio = 2
  	}
  
  	--helper.TablePrint(Properties, 1)
  	if(Properties['Output Count'].Value > 0 and Properties['Input Count'].Value > 0) then
  		for o = 0, Properties['Output Count'].Value-1 do
  
        Controls["output_" .. o .. "-lock"].EventHandler = function(ctl) 
    			if DebugFunction then print("output_" .. o .. "-lock pressed: "..tostring(ctl.Boolean)) end
          SetOutputLock(o, ctl.Boolean)
        end
  
  			for i = 0, Properties['Input Count'].Value-1 do
  				-- Crosspoint EventHandlers
  				Controls["vid-input_" .. i .. "-output_" .. o].EventHandler = function(ctl) 
  					if DebugFunction then print("vid-input_" .. i .. "-output_" .. o .. " pressed") end
  					SetRoute(Layers.Video, o, i, ctl.Value)
  					if(o == 0) then ctl.Value = 0 end -- let the individual output buttons track state
  				end
  			end
  			
  		end
  	
  	end
  
  	Disconnected()
  	Connect()
  	--TestFeedbacks()
  	--Heartbeat:Start(PollRate)
  end
  
  -- Timer EventHandlers  --
  Heartbeat.EventHandler = function()
  	if DebugFunction then print("Heartbeat Event Handler Called - CommandQueue size: "..#CommandQueue) end
  end
  
  SetupDebugPrint()
  Initialize()
end
